---
title: "Forecast Report"
author: "Provided by Quantico"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  prettydoc::html_pretty:
    theme: cayman
    toc: yes
    toc_depth: 1
    fig_caption: yes
    number_sections: no
classoption: landscape
---

```{r Environment, include=FALSE}
# theme options up top: hpstr, cayman, architect, AutoQuant
knitr::opts_chunk$set(echo = TRUE)
temp <- globalenv()
TempNames <- names(temp)
for(nam in TempNames) {
  assign(x = nam, value = eval(temp[[nam]]), envir = .GlobalEnv)
}
```

```{css, echo=FALSE}
@import url('https://fonts.googleapis.com/css2?family=Yusei+Magic&display=swap');

* {
  box-sizing: border-box;
}

body {
  padding: 0;
  margin: 0;
  font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 16px;
  line-height: 1.5;
  color: #000000;
  background: linear-gradient(180deg, #787989, #b7b8cf);
}

a {
  color: #b1c5d8;
  text-decoration: none;
}
a:hover {
  text-decoration: underline;
}

.page-header {
  color: #fff;
  text-align: center;
  background-color: #000121;
  background-image: linear-gradient(120deg,#000121,#696b76);
  padding: 1.5rem 2rem;
}
.page-header :last-child {
  margin-bottom: 0.5rem;
}
@media screen and (max-width: 42em) {
  .page-header {
    padding: 1rem 1rem;
  }
}

.project-name {
  margin-top: 0;
  margin-bottom: 0.1rem;
  font-size: 2rem;
}
@media screen and (max-width: 42em) {
  .project-name {
    font-size: 1.75rem;
  }
}

.project-tagline {
  margin-bottom: 2rem;
  font-weight: normal;
  opacity: 0.7;
  font-size: 1.5rem;
}
@media screen and (max-width: 42em) {
  .project-tagline {
    font-size: 1.2rem;
  }
}

.project-author, .project-date {
  font-weight: normal;
  opacity: 0.7;
  font-size: 1.2rem;
}
@media screen and (max-width: 42em) {
  .project-author, .project-date {
    font-size: 1rem;
  }
}

.main-content, .toc {
  max-width: 64rem;
  padding: 2rem 4rem;
  margin: 0 auto;
  font-size: 1.1rem;
}

.toc {
  padding-bottom: 0;
}
.toc .toc-box {
  padding: 55px;
  background: linear-gradient(90deg, #000121, #696b76);
  border: solid 1px #000000;
  border-radius: 70px;
  color: white;
  box-shadow: 8px 5px 10px 0px #000000;
}
.toc .toc-box .toc-title {
  margin: 0 0 0.5rem;
  text-align: center;
}
.toc .toc-box > ul {
  margin: 0;
  padding-left: 1.5rem;
}
@media screen and (min-width: 42em) and (max-width: 64em) {
  .toc {
    padding: 2rem 2rem 0;
  }
}
@media screen and (max-width: 42em) {
  .toc {
    padding: 2rem 1rem 0;
    font-size: 1rem;
  }
}

.main-content :first-child {
  margin-top: 0;
}
@media screen and (min-width: 42em) and (max-width: 64em) {
  .main-content {
    padding: 2rem;
  }
}
@media screen and (max-width: 42em) {
  .main-content {
    padding: 2rem 1rem;
    font-size: 1rem;
  }
}
.main-content img {
  max-width: 100%;
}

.main-content h1  {
  margin-top: 2rem;
  margin-bottom: 1rem;
  font-weight: bold;
  color: #070e56;
}

.main-content h2 {
  margin-top: 2rem;
  margin-bottom: 1rem;
  font-weight: normal;
  color: #121e94;
}
.main-content h3 {
  margin-top: 2rem;
  margin-bottom: 1rem;
  font-weight: normal;
  color: #3745d1;
}
.main-content h4 {
  margin-top: 2rem;
  margin-bottom: 1rem;
  font-weight: normal;
  color: #374995;
}
.main-content h5 {
  margin-top: 2rem;
  margin-bottom: 1rem;
  font-weight: normal;
  color: #000000;
}
.main-content h6 {
  margin-top: 2rem;
  margin-bottom: 1rem;
  font-weight: normal;
  color: #000000;
}

.main-content p {
  margin-bottom: 1em;
}
.main-content code {
  padding: 2px 4px;
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  color: #2c2c2d;
  background-color: #f3f6fa;
  border-radius: 0.3rem;
}
.main-content pre {
  padding: 0.8rem;
  margin-top: 0;
  margin-bottom: 1rem;
  font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
  color: #2c2c2d;
  word-wrap: normal;
  background-color: #e9edf9c9;
  border: solid 1px #001a35;
  border-radius: 0.3rem;
  line-height: 1.45;
  overflow: auto;
}
@media screen and (max-width: 42em) {
  .main-content pre {
    font-size: 0.9rem;
  }
}
.main-content pre > code {
  padding: 0;
  margin: 0;
  color: #2c2c2d;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}
@media screen and (max-width: 42em) {
  .main-content pre > code {
    font-size: 0.9rem;
  }
}
.main-content pre code,
.main-content pre tt {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}
.main-content pre code:before, .main-content pre code:after,
.main-content pre tt:before,
.main-content pre tt:after {
  content: normal;
}
.main-content ul,
.main-content ol {
  margin-top: 0;
}
.main-content blockquote {
  padding: 0 1rem;
  margin-left: 0;
  color: #2c2c2d;
  border-left: 0.3rem solid #dce6f0;
  font-size: 1.2rem;
}
.main-content blockquote > :first-child {
  margin-top: 0;
}
.main-content blockquote > :last-child {
  margin-bottom: 0;
}
@media screen and (max-width: 42em) {
  .main-content blockquote {
    font-size: 1.1rem;
  }
}
.main-content table {
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
  -webkit-overflow-scrolling: touch;
  border-collapse: collapse;
  border-spacing: 0;
  margin: 1rem 0;
}
.main-content table th {
  font-weight: bold;
  background-color: #159957;
  color: #fff;
}
.main-content table th,
.main-content table td {
  padding: 0.5rem 1rem;
  border-bottom: 1px solid #e9ebec;
  text-align: left;
}
.main-content table tr:nth-child(odd) {
  background-color: #f2f2f2;
}
.main-content dl {
  padding: 0;
}
.main-content dl dt {
  padding: 0;
  margin-top: 1rem;
  font-size: 1rem;
  font-weight: bold;
}
.main-content dl dd {
  padding: 0;
  margin-bottom: 1rem;
}
.main-content hr {
  height: 2px;
  padding: 0;
  margin: 1rem 0;
  background-color: #eff0f1;
  border: 0;
}
```

```{r FC_Objects, echo = FALSE}
if(length(MOL) > 0L && length(DataList) > 0L) {
  
  # @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ ----
  # Create collection lists                                                   ----
  # @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ ----

  if(length(ScoringData) > 0L) {

    # Metrics
    ScoringData[, AvgError := get(TargetColumnName) - Predict]
    AvgError <- round(ScoringData[, mean(AvgError, na.rm = TRUE)], 4)
    ScoringData[, MAE := abs(AvgError)]
    MAE <- round(ScoringData[, mean(MAE, na.rm = TRUE)], 4)
    ScoringData[, MSE := (get(TargetColumnName) - Predict)^2]
    RMSE <- round(sqrt(ScoringData[, mean(MSE, na.rm = TRUE)]), 4)
    # ScoringData[, MAPE := get(TargetColumnName) / Predict - 1]
    # MAPE <- paste0(round(ScoringData[Predict != 0, mean(MAPE, na.rm = TRUE)], 4) * 100, "%")
    ScoringData[, SMAPE := 2 * MAE / (abs(get(TargetColumnName)) + abs(Predict))]
    SMAPE <- paste0(round(ScoringData[, mean(SMAPE, na.rm = TRUE)], 4) * 100, "%")

    MetricsTable <- data.table::data.table(AvgError, MAE, RMSE, SMAPE)

    # Evaluation Metrics ----
    ML_Evaluation_Metrics <- reactable::reactable(
      data = MetricsTable,
      compact = TRUE,
      defaultPageSize = 10,
      wrap = TRUE,
      filterable = TRUE,
      fullWidth = TRUE,
      highlight = TRUE,
      pagination = TRUE,
      resizable = TRUE,
      searchable = TRUE,
      selection = "multiple",
      showPagination = TRUE,
      showSortable = TRUE,
      showSortIcon = TRUE,
      sortable = TRUE,
      striped = TRUE,
      theme = reactable::reactableTheme(
        color = "black",
        backgroundColor = "#4f4f4f26",
        borderColor = "#dfe2e5",
        stripedColor = "#4f4f4f8f",
        highlightColor = "#8989898f",
        cellPadding = "8px 12px",
        style = list(
          fontFamily = "-apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif"
        ),
        searchInputStyle = list(width = "100%")
      )
    )

    # Variable Importance
    if(tolower(Algo) == "catboost") {
      Test_Importance <- DataList[[paste0("CatBoostFC_", ModelID, "_Test_VI_Data")]]$data
    } else if(tolower(Algo) == "xgboost") {
      Test_Importance <- DataList[[paste0("XGBoostFC_", ModelID, "_Test_VI_Data")]]$data
    } else if(tolower(Algo) == "lightgbm") {
      Test_Importance <- DataList[[paste0("LightGBMFC_", ModelID, "_Test_VI_Data")]]$data
    }

    # Test Importance ----
    ML_Test_Importance <- reactable::reactable(
      data = Test_Importance,
      compact = TRUE,
      defaultPageSize = 10,
      wrap = TRUE,
      filterable = TRUE,
      fullWidth = TRUE,
      highlight = TRUE,
      pagination = TRUE,
      resizable = TRUE,
      searchable = TRUE,
      selection = "multiple",
      showPagination = TRUE,
      showSortable = TRUE,
      showSortIcon = TRUE,
      sortable = TRUE,
      striped = TRUE,
      theme = reactable::reactableTheme(
        color = "black",
        backgroundColor = "#4f4f4f26",
        borderColor = "#dfe2e5",
        stripedColor = "#4f4f4f8f",
        highlightColor = "#8989898f",
        cellPadding = "8px 12px",
        style = list(
          fontFamily = "-apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif"
        ),
        searchInputStyle = list(width = "100%")
      )
    )


    Validation_Importance <- tryCatch({DataList[[paste0("CatBoostFC_", ModelID, "_Validation_VI_Data")]]$data}, error = function(x) NULL)

    # Validation Importance ----
    if(length(Validation_Importance) > 0) {
      ML_Validation_Importance <- reactable::reactable(
        data = Validation_Importance,
        compact = TRUE,
        defaultPageSize = 10,
        wrap = TRUE,
        filterable = TRUE,
        fullWidth = TRUE,
        highlight = TRUE,
        pagination = TRUE,
        resizable = TRUE,
        searchable = TRUE,
        selection = "multiple",
        showPagination = TRUE,
        showSortable = TRUE,
        showSortIcon = TRUE,
        sortable = TRUE,
        striped = TRUE,
        theme = reactable::reactableTheme(
          color = "black",
          backgroundColor = "#4f4f4f26",
          borderColor = "#dfe2e5",
          stripedColor = "#4f4f4f8f",
          highlightColor = "#8989898f",
          cellPadding = "8px 12px",
          style = list(
            fontFamily = "-apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif"
          ),
          searchInputStyle = list(width = "100%")
        )
      )
    }

    Train_Importance <- tryCatch({DataList[[paste0("CatBoostFC_", ModelID, "_Train_VI_Data")]]$data}, error = function(x) NULL)

    # Train Importance ----
    if(length(Train_Importance) > 0) {
      ML_Train_Importance <- reactable::reactable(
        data = Train_Importance,
        compact = TRUE,
        defaultPageSize = 10,
        wrap = TRUE,
        filterable = TRUE,
        fullWidth = TRUE,
        highlight = TRUE,
        pagination = TRUE,
        resizable = TRUE,
        searchable = TRUE,
        selection = "multiple",
        showPagination = TRUE,
        showSortable = TRUE,
        showSortIcon = TRUE,
        sortable = TRUE,
        striped = TRUE,
        theme = reactable::reactableTheme(
          color = "black",
          backgroundColor = "#4f4f4f26",
          borderColor = "#dfe2e5",
          stripedColor = "#4f4f4f8f",
          highlightColor = "#8989898f",
          cellPadding = "8px 12px",
          style = list(
            fontFamily = "-apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif"
          ),
          searchInputStyle = list(width = "100%")
        )
      )
    }

    # Interaction Importances
    All_Interaction <- tryCatch({DataList[[paste0("CatBoostFC_", ModelID, "_All_II_Data")]]$data}, error = function(x) NULL)

    # Interaction Importance ----
    if(length(All_Interaction) > 0) {
      ML_Interaction_Importance <- reactable::reactable(
        data = All_Interaction,
        compact = TRUE,
        defaultPageSize = 10,
        wrap = TRUE,
        filterable = TRUE,
        fullWidth = TRUE,
        highlight = TRUE,
        pagination = TRUE,
        resizable = TRUE,
        searchable = TRUE,
        selection = "multiple",
        showPagination = TRUE,
        showSortable = TRUE,
        showSortIcon = TRUE,
        sortable = TRUE,
        striped = TRUE,
        theme = reactable::reactableTheme(
          color = "black",
          backgroundColor = "#4f4f4f26",
          borderColor = "#dfe2e5",
          stripedColor = "#4f4f4f8f",
          highlightColor = "#8989898f",
          cellPadding = "8px 12px",
          style = list(
            fontFamily = "-apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif"
          ),
          searchInputStyle = list(width = "100%")
        )
      )
    }

    # Evaluation Plots ----
    ScoringData_Residual_Histogram <- AutoPlots::Plot.Residuals.Histogram(
      dt = ScoringData,
      AggMethod = "mean",
      SampleSize = 30000,
      XVar = 'Predict',
      YVar = TargetColumnName,
      GroupVar = NULL,
      YVarTrans = "Identity",
      XVarTrans = "Identity",
      FacetRows = 1,
      FacetCols = 1,
      FacetLevels = NULL,
      NumberBins = 20,
      Height = "600px",
      Width = "975px",
      Title = "Residuals Histogram",
      ShowLabels = FALSE,
      Title.YAxis = TargetColumnName,
      Title.XAxis = 'Predict',
      EchartsTheme = "wef",
      TimeLine = FALSE,
      X_Scroll = TRUE,
      Y_Scroll = FALSE,
      TextColor = "white",
      title.fontSize = 22,
      title.fontWeight = "bold",
      title.textShadowColor = "#63aeff",
      title.textShadowBlur = 3,
      title.textShadowOffsetY = 1,
      title.textShadowOffsetX = -1,
      xaxis.fontSize = 14,
      yaxis.fontSize = 14,
      Debug = FALSE)

    ScoringData_Calibration_Plot <- AutoPlots::Plot.Calibration.Line(
      dt = ScoringData,
      AggMethod = "mean",
      XVar = 'Predict',
      YVar = TargetColumnName,
      GroupVar = NULL,
      YVarTrans = "Identity",
      XVarTrans = "Identity",
      FacetRows = 1,
      FacetCols = 1,
      FacetLevels = NULL,
      NumberBins = 20,
      Height = "600px",
      Width = "975px",
      Title = "Calibration Line Plot",
      ShowLabels = FALSE,
      Title.YAxis = TargetColumnName,
      Title.XAxis = "Predict",
      EchartsTheme = "wef",
      TimeLine = FALSE,
      X_Scroll = TRUE,
      Y_Scroll = TRUE,
      TextColor = "white",
      Debug = FALSE)

    ScoringData_Calibration_Box_Plot <- AutoPlots::Plot.Calibration.Box(
      dt = ScoringData,
      SampleSize = 30000L,
      AggMethod = "mean",
      XVar = 'Predict',
      YVar = TargetColumnName,
      GroupVar = NULL,
      YVarTrans = "Identity",
      XVarTrans = "Identity",
      FacetRows = 1,
      FacetCols = 1,
      FacetLevels = NULL,
      NumberBins = 20,
      Height = "600px",
      Width = "975px",
      Title = "Calibration Plot",
      ShowLabels = FALSE,
      Title.YAxis = TargetColumnName,
      Title.XAxis = "Predict",
      EchartsTheme = "wef",
      TimeLine = FALSE,
      X_Scroll = TRUE,
      Y_Scroll = TRUE,
      TextColor = "white",
      Debug = FALSE)

    # Add Plots
    if(!is.null(ScoringData) && !is.null(FeatureColumnNames)) {
      ScoringData_Partial_Dependence_Line_Plot <- list()
      for(g in FeatureColumnNames) {
        if(is.numeric(ScoringData[[g]])) {
          ScoringData_Partial_Dependence_Line_Plot[[g]] <- AutoPlots::Plot.PartialDependence.Line(
            dt = ScoringData,
            XVar = g,
            YVar = TargetColumnName,
            ZVar = 'Predict',
            YVarTrans = "Identity",
            XVarTrans = "Identity",
            ZVarTrans = "Identity",
            FacetRows = 1,
            FacetCols = 1,
            FacetLevels = NULL,
            GroupVar = NULL,
            NumberBins = 20,
            AggMethod = "mean",
            Height = "600px",
            Width = "975px",
            Title = "Partial Dependence Line",
            ShowLabels = FALSE,
            Title.YAxis = TargetColumnName,
            Title.XAxis = g,
            EchartsTheme = "wef",
            TimeLine = FALSE,
            X_Scroll = TRUE,
            Y_Scroll = TRUE,
            TextColor = "white",
            Debug = FALSE)
        }
      }
    }

    # Add Plots
    if(!is.null(ScoringData) && !is.null(FeatureColumnNames)) {
      ScoringData_Partial_Dependence_Box_Plot <- list()
      for(g in FeatureColumnNames) {
        if(is.numeric(ScoringData[[g]])) {
          ScoringData_Partial_Dependence_Box_Plot[[g]] <- AutoPlots::Plot.PartialDependence.Box(
            dt = ScoringData,
            XVar = g,
            YVar = TargetColumnName,
            ZVar = 'Predict',
            YVarTrans = "Identity",
            XVarTrans = "Identity",
            ZVarTrans = "Identity",
            FacetRows = 1,
            FacetCols = 1,
            FacetLevels = NULL,
            GroupVar = GroupVariableInclude,
            NumberBins = 20,
            AggMethod = "mean",
            Height = "600px",
            Width = "975px",
            Title = "Partial Dependence Line",
            ShowLabels = FALSE,
            Title.YAxis = TargetColumnName,
            Title.XAxis = g,
            EchartsTheme = "wef",
            TimeLine = FALSE,
            X_Scroll = TRUE,
            Y_Scroll = TRUE,
            TextColor = "white",
            Debug = FALSE)
        }
      }
    }

    # Add Plots
    if(!is.null(ScoringData) && !is.null(FeatureColumnNames)) {
      if("GroupVar" %in% names(ScoringData)) {
        data.table::setnames(ScoringData, "GroupVar", "GroupVariable")
        FeatureColumnNames <- FeatureColumnNames[!FeatureColumnNames %in% "GroupVar"]
        FeatureColumnNames[[length(FeatureColumnNames) + 1]] <- "GroupVariable"
      } else if("GroupVariable" %in% names(ScoringData)) {
        FeatureColumnNames <- FeatureColumnNames[!FeatureColumnNames %in% "GroupVar"]
        FeatureColumnNames[[length(FeatureColumnNames) + 1]] <- "GroupVariable"
      }

      ScoringData_Partial_Dependence_Bar_Plot <- list()
      for(g in FeatureColumnNames) {
        if(g %in% names(ScoringData) && !is.numeric(ScoringData[[g]])) {
          ScoringData_Partial_Dependence_Bar_Plot[[g]] <- AutoPlots::Plot.PartialDependence.HeatMap(
            dt = ScoringData,
            XVar = g,
            YVar = TargetColumnName,
            ZVar = 'Predict',
            YVarTrans = "Identity",
            XVarTrans = "Identity",
            ZVarTrans = "Identity",
            FacetRows = 1,
            FacetCols = 1,
            FacetLevels = NULL,
            GroupVar = NULL,
            NumberBins = 20,
            AggMethod = "mean",
            Height = "600px",
            Width = "975px",
            Title = "Partial Dependence BarPlot",
            ShowLabels = FALSE,
            Title.YAxis = TargetColumnName,
            Title.XAxis = g,
            EchartsTheme = "wef",
            TimeLine = FALSE,
            X_Scroll = TRUE,
            Y_Scroll = TRUE,
            TextColor = "white",
            Debug = FALSE)
        }
      }
    }
  } else {
    ML_Evaluation_Metrics <- NULL
    ML_Test_Importance <- NULL
    ML_Validation_Importance <- NULL
    ML_Train_Importance <- NULL
    ML_Interaction_Importance <- NULL
    ScoringData_Residual_Histogram <- NULL
    ScoringData_Calibration_Plot <- NULL
    ScoringData_Calibration_Box_Plot <- NULL
    ScoringData_Partial_Dependence_Line_Plot <- NULL
    ScoringData_Partial_Dependence_Box_Plot <- NULL
    ScoringData_Partial_Dependence_Bar_Plot <- NULL
  }

  # ----

  # ----

  # @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ ----
  # Backtest Outputs                                                          ----
  # @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ ----

  # BT_Rollup
  BT_Rollup <- tryCatch({DataList[[paste0(ModelID, "_BT_Rollup")]]$data}, error = function(x) NULL)
  if(length(BT_Rollup) > 0L) {
    Back_Test_Metrics <- reactable::reactable(
      data = BT_Rollup,
      compact = TRUE,
      defaultPageSize = 10,
      wrap = TRUE,
      filterable = TRUE,
      fullWidth = TRUE,
      highlight = TRUE,
      pagination = TRUE,
      resizable = TRUE,
      searchable = TRUE,
      selection = "multiple",
      showPagination = TRUE,
      showSortable = TRUE,
      showSortIcon = TRUE,
      sortable = TRUE,
      striped = TRUE,
      theme = reactable::reactableTheme(
        color = "black",
        backgroundColor = "#4f4f4f26",
        borderColor = "#dfe2e5",
        stripedColor = "#4f4f4f8f",
        highlightColor = "#8989898f",
        cellPadding = "8px 12px",
        style = list(
          fontFamily = "-apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif"
        ),
        searchInputStyle = list(width = "100%")
      )
    )
  } else {
    Back_Test_Metrics <- NULL
    p1 <- NULL
    p2 <- NULL
    p3 <- NULL
    p4 <- NULL
    p6 <- NULL
  }

  # BT_Raw
  BT_Raw <- tryCatch({DataList[[paste0(ModelID, "_BT_Raw")]]$data}, error = function(x) NULL)
  if(length(BT_Raw) > 0L) {

    # Backtest
    minD <- BT_Raw[DataSet == "Evaluation", min(get(DateColumnName))]
    p1 <- AutoPlots::Plot.Line(
      dt = BT_Raw,
      AggMethod = "mean",
      PreAgg = FALSE,
      XVar = DateColumnName,
      YVar = c(TargetColumnName, "Predictions"),
      DualYVar = NULL,
      GroupVar = NULL,
      YVarTrans = "Identity",
      DualYVarTrans = "Identity",
      XVarTrans = "Identity",
      FacetRows = 1,
      FacetCols = 1,
      FacetLevels = NULL,
      Height = "600px",
      Width = "975px",
      Title = "Line Plot",
      ShowLabels = FALSE,
      Title.YAxis = paste0(TargetColumnName, " | Predict"),
      Title.XAxis = DateColumnName,
      EchartsTheme = "wef",
      X_Scroll = FALSE,
      Y_Scroll = FALSE,
      TimeLine = TRUE,
      Alpha = 0.5,
      Smooth = TRUE,
      ShowSymbol = FALSE,
      TextColor = "white",
      title.fontSize = 22,
      title.fontWeight = "bold",
      title.textShadowColor = "#63aeff",
      title.textShadowBlur = 3,
      title.textShadowOffsetY = 1,
      title.textShadowOffsetX = -1,
      xaxis.fontSize = 14,
      yaxis.fontSize = 14,
      xaxis.rotate = 0,
      yaxis.rotate = 0,
      ContainLabel = TRUE,
      Debug = FALSE)
    p1 <- echarts4r::e_mark_line(e = p1, data = list(xAxis = minD), title = "")

    # Backtest AvgError
    p2 <- AutoPlots::Plot.Box(
      dt = BT_Raw,
      SampleSize = 100000L,
      XVar = DateColumnName,
      YVar = "AvgError",
      GroupVar = NULL,
      YVarTrans = "Identity",
      XVarTrans = "Identity",
      FacetRows = 1,
      FacetCols = 1,
      FacetLevels = NULL,
      Height = "600px",
      Width = "975px",
      Title = "Box Plot: Avg Error",
      ShowLabels = FALSE,
      Title.YAxis = paste0(TargetColumnName, " - Predicted"),
      Title.XAxis = DateColumnName,
      EchartsTheme = "wef",
      TimeLine = FALSE,
      X_Scroll = TRUE,
      Y_Scroll = TRUE,
      TextColor = "white",
      title.fontSize = 22,
      title.fontWeight = "bold",
      title.textShadowColor = "#63aeff",
      title.textShadowBlur = 3,
      title.textShadowOffsetY = 1,
      title.textShadowOffsetX = -1,
      xaxis.fontSize = 14,
      yaxis.fontSize = 14,
      xaxis.rotate = 0,
      yaxis.rotate = 0,
      ContainLabel = TRUE,
      Debug = FALSE)
    p2 <- echarts4r::e_mark_line(e = p2, data = list(xAxis = minD), title = "")

    # Backtest MAE
    p3 <- AutoPlots::Plot.Area(
      dt = BT_Raw,
      AggMethod = "mean",
      PreAgg = FALSE,
      XVar = DateColumnName,
      YVar = "MAE",
      DualYVar = NULL,
      GroupVar = NULL,
      YVarTrans = "Identity",
      DualYVarTrans = "Identity",
      XVarTrans = "Identity",
      FacetRows = 1,
      FacetCols = 1,
      FacetLevels = NULL,
      Height = "600px",
      Width = "975px",
      Title = "Line Plot",
      ShowLabels = FALSE,
      Title.YAxis = "Absolute Error",
      Title.XAxis = DateColumnName,
      EchartsTheme = "wef",
      X_Scroll = FALSE,
      Y_Scroll = FALSE,
      TimeLine = TRUE,
      Alpha = 0.5,
      Smooth = TRUE,
      ShowSymbol = FALSE,
      TextColor = "white",
      title.fontSize = 22,
      title.fontWeight = "bold",
      title.textShadowColor = "#63aeff",
      title.textShadowBlur = 3,
      title.textShadowOffsetY = 1,
      title.textShadowOffsetX = -1,
      xaxis.fontSize = 14,
      yaxis.fontSize = 14,
      xaxis.rotate = 0,
      yaxis.rotate = 0,
      ContainLabel = TRUE,
      Debug = FALSE)
    p3 <- echarts4r::e_mark_line(e = p3, data = list(xAxis = minD), title = "")

    # Backtest RMSE
    temp <- BT_Raw[, list(RMSE = sqrt(mean(RMSE))), by = DateColumnName]
    p4 <- AutoPlots::Plot.Area(
      dt = temp,
      AggMethod = "mean",
      PreAgg = TRUE,
      XVar = DateColumnName,
      YVar = "RMSE",
      DualYVar = NULL,
      GroupVar = NULL,
      YVarTrans = "Identity",
      DualYVarTrans = "Identity",
      XVarTrans = "Identity",
      FacetRows = 1,
      FacetCols = 1,
      FacetLevels = NULL,
      Height = "600px",
      Width = "975px",
      Title = "Line Plot",
      ShowLabels = FALSE,
      Title.YAxis = "MSE",
      Title.XAxis = DateColumnName,
      EchartsTheme = "wef",
      X_Scroll = FALSE,
      Y_Scroll = FALSE,
      TimeLine = TRUE,
      Alpha = 0.5,
      Smooth = TRUE,
      ShowSymbol = FALSE,
      TextColor = "white",
      title.fontSize = 22,
      title.fontWeight = "bold",
      title.textShadowColor = "#63aeff",
      title.textShadowBlur = 3,
      title.textShadowOffsetY = 1,
      title.textShadowOffsetX = -1,
      xaxis.fontSize = 14,
      yaxis.fontSize = 14,
      xaxis.rotate = 0,
      yaxis.rotate = 0,
      ContainLabel = TRUE,
      Debug = FALSE)
    p4 <- echarts4r::e_mark_line(e = p4, data = list(xAxis = minD), title = "")

    # # Backtest MAPE
    # temp1 <- BT_Raw[, list(MAPE = mean(MAPE)), by = DateColumnName]
    # p5 <- AutoPlots::Plot.Area(
    #   dt = temp1,
    #   AggMethod = "mean",
    #   PreAgg = TRUE,
    #   XVar = DateColumnName,
    #   YVar = "MAPE",
    #   DualYVar = NULL,
    #   GroupVar = NULL,
    #   YVarTrans = "Identity",
    #   DualYVarTrans = "Identity",
    #   XVarTrans = "Identity",
    #   FacetRows = 1,
    #   FacetCols = 1,
    #   FacetLevels = NULL,
    #   Height = "600px",
    #   Width = "975px",
    #   Title = "Line Plot",
    #   ShowLabels = FALSE,
    #   Title.YAxis = "MAPE",
    #   Title.XAxis = DateColumnName,
    #   EchartsTheme = "wef",
    #   X_Scroll = FALSE,
    #   Y_Scroll = FALSE,
    #   TimeLine = TRUE,
    #   Alpha = 0.5,
    #   Smooth = TRUE,
    #   ShowSymbol = FALSE,
    #   TextColor = "white",
    #   title.fontSize = 22,
    #   title.fontWeight = "bold",
    #   title.textShadowColor = "#63aeff",
    #   title.textShadowBlur = 3,
    #   title.textShadowOffsetY = 1,
    #   title.textShadowOffsetX = -1,
    #   xaxis.fontSize = 14,
    #   yaxis.fontSize = 14,
    #   xaxis.rotate = 0,
    #   yaxis.rotate = 0,
    #   ContainLabel = TRUE,
    #   Debug = FALSE)
    # OutputList[["Backtest MAPE LinePlot"]] <- echarts4r::e_mark_line(e = p5, data = list(xAxis = minD), title = "")

    # Backtest SMAPE
    temp2 <- BT_Raw[, list(SMAPE = mean(SMAPE)), by = DateColumnName]
    p6 <- AutoPlots::Plot.Area(
      dt = temp2,
      AggMethod = "mean",
      PreAgg = TRUE,
      XVar = DateColumnName,
      YVar = "SMAPE",
      DualYVar = NULL,
      GroupVar = NULL,
      YVarTrans = "Identity",
      DualYVarTrans = "Identity",
      XVarTrans = "Identity",
      FacetRows = 1,
      FacetCols = 1,
      FacetLevels = NULL,
      Height = "600px",
      Width = "975px",
      Title = "Line Plot",
      ShowLabels = FALSE,
      Title.YAxis = "SMAPE",
      Title.XAxis = DateColumnName,
      EchartsTheme = "wef",
      X_Scroll = FALSE,
      Y_Scroll = FALSE,
      TimeLine = TRUE,
      Alpha = 0.5,
      Smooth = TRUE,
      ShowSymbol = FALSE,
      TextColor = "white",
      title.fontSize = 22,
      title.fontWeight = "bold",
      title.textShadowColor = "#63aeff",
      title.textShadowBlur = 3,
      title.textShadowOffsetY = 1,
      title.textShadowOffsetX = -1,
      xaxis.fontSize = 14,
      yaxis.fontSize = 14,
      xaxis.rotate = 0,
      yaxis.rotate = 0,
      ContainLabel = TRUE,
      Debug = FALSE)
    p6 <- echarts4r::e_mark_line(e = p6, data = list(xAxis = minD), title = "")

  }

  # ----

  # ----

  # @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ ----
  # FE Test Outputs                                                           ----
  # @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ ----

  # FE_Test
  FE_Test <- tryCatch({DataList[[paste0(ModelID, "_FeatureEngineeringTest")]]$data}, error = function(x) NULL)
  if(length(FE_Test) > 0L) {
    Feature_Tuning_Metrics <- reactable::reactable(
      data = FE_Test,
      compact = TRUE,
      defaultPageSize = 10,
      wrap = TRUE,
      filterable = TRUE,
      fullWidth = TRUE,
      highlight = TRUE,
      pagination = TRUE,
      resizable = TRUE,
      searchable = TRUE,
      selection = "multiple",
      showPagination = TRUE,
      showSortable = TRUE,
      showSortIcon = TRUE,
      sortable = TRUE,
      striped = TRUE,
      theme = reactable::reactableTheme(
        color = "black",
        backgroundColor = "#4f4f4f26",
        borderColor = "#dfe2e5",
        stripedColor = "#4f4f4f8f",
        highlightColor = "#8989898f",
        cellPadding = "8px 12px",
        style = list(
          fontFamily = "-apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif"
        ),
        searchInputStyle = list(width = "100%")
      )
    )
  } else {Feature_Tuning_Metrics <- NULL}

  # FE_Test[, ]

  # ----

  # ----

  # @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ ----
  # Cross Eval Outputs                                                        ----
  # @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ ----

  # FE_Test
  CE_Rollup <- tryCatch({DataList[[paste0(ModelID, "_CE_Rollup")]]$data}, error = function(x) NULL)
  if(length(CE_Rollup) > 0L) {
    Cross_Eval_Test_Metrics <- reactable::reactable(
      data = CE_Rollup,
      compact = TRUE,
      defaultPageSize = 10,
      wrap = TRUE,
      filterable = TRUE,
      fullWidth = TRUE,
      highlight = TRUE,
      pagination = TRUE,
      resizable = TRUE,
      searchable = TRUE,
      selection = "multiple",
      showPagination = TRUE,
      showSortable = TRUE,
      showSortIcon = TRUE,
      sortable = TRUE,
      striped = TRUE,
      theme = reactable::reactableTheme(
        color = "black",
        backgroundColor = "#4f4f4f26",
        borderColor = "#dfe2e5",
        stripedColor = "#4f4f4f8f",
        highlightColor = "#8989898f",
        cellPadding = "8px 12px",
        style = list(
          fontFamily = "-apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif"
        ),
        searchInputStyle = list(width = "100%")
      )
    )
  } else {Cross_Eval_Test_Metrics <- NULL}

  # ----

  # ----

  # @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ ----
  # Forecast Outputs                                                          ----
  # @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ ----

  # FC Data Output
  FCData <- tryCatch({DataList[[paste0("FC_", ModelID)]][['data']]}, error = function(x) NULL)
  if(length(FCData) > 0L) {
    Panel_Forecast_Data <- reactable::reactable(
      data = FCData,
      compact = TRUE,
      defaultPageSize = 10,
      wrap = TRUE,
      filterable = TRUE,
      fullWidth = TRUE,
      highlight = TRUE,
      pagination = TRUE,
      resizable = TRUE,
      searchable = TRUE,
      selection = "multiple",
      showPagination = TRUE,
      showSortable = TRUE,
      showSortIcon = TRUE,
      sortable = TRUE,
      striped = TRUE,
      theme = reactable::reactableTheme(
        color = "black",
        backgroundColor = "#4f4f4f26",
        borderColor = "#dfe2e5",
        stripedColor = "#4f4f4f8f",
        highlightColor = "#8989898f",
        cellPadding = "8px 12px",
        style = list(
          fontFamily = "-apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif"
        ),
        searchInputStyle = list(width = "100%")
      )
    )

    # Backtest
    minD <- FCData[is.na(get(TargetColumnName)), min(get(DateColumnName), na.rm = TRUE)]
    p7 <- AutoPlots::Plot.Line(
      dt = FCData,
      AggMethod = "mean",
      PreAgg = FALSE,
      XVar = DateColumnName,
      YVar = c(TargetColumnName, "Predictions"),
      DualYVar = NULL,
      GroupVar = NULL,
      YVarTrans = "Identity",
      DualYVarTrans = "Identity",
      XVarTrans = "Identity",
      FacetRows = 1,
      FacetCols = 1,
      FacetLevels = NULL,
      Height = "600px",
      Width = "975px",
      Title = "Line Plot",
      ShowLabels = FALSE,
      Title.YAxis = paste0(TargetColumnName, " | Predict"),
      Title.XAxis = DateColumnName,
      EchartsTheme = "wef",
      X_Scroll = FALSE,
      Y_Scroll = FALSE,
      TimeLine = TRUE,
      Alpha = 0.5,
      Smooth = TRUE,
      ShowSymbol = FALSE,
      TextColor = "white",
      title.fontSize = 22,
      title.fontWeight = "bold",
      title.textShadowColor = "#63aeff",
      title.textShadowBlur = 3,
      title.textShadowOffsetY = 1,
      title.textShadowOffsetX = -1,
      xaxis.fontSize = 14,
      yaxis.fontSize = 14,
      xaxis.rotate = 0,
      yaxis.rotate = 0,
      ContainLabel = TRUE,
      Debug = FALSE)
    p7 <- echarts4r::e_mark_line(e = p7, data = list(xAxis = minD), title = "")
  } else {
    Panel_Forecast_Data <- NULL
    p7 <- NULL
  }

  # ----

  # ----
  
} else {
  
  ML_Evaluation_Metrics <- NULL
  ML_Test_Importance <- NULL
  ML_Validation_Importance <- NULL
  ML_Train_Importance <- NULL
  ML_Interaction_Importance <- NULL
  ScoringData_Residual_Histogram <- NULL
  ScoringData_Calibration_Plot <- NULL
  ScoringData_Calibration_Box_Plot <- NULL
  ScoringData_Partial_Dependence_Line_Plot <- NULL
  ScoringData_Partial_Dependence_Box_Plot <- NULL
  ScoringData_Partial_Dependence_Bar_Plot <- NULL
  p1 <- NULL
  p2 <- NULL
  p3 <- NULL
  p4 <- NULL
  p6 <- NULL
  Feature_Tuning_Metrics <- NULL
  Cross_Eval_Test_Metrics <- NULL
  p7 <- NULL
}
``` 

# <font size="6">Forecasting Report Descriptions:</font>

The two main goals with this document are to provide a wide range of output to investigate high level performance and insights, and to deliver a high quality report design layout to increase user experience. The metrics provided are intended to be semi-comprehensive. One can always dig deeper into results to gain further insights. In light of that, the results are intended to provide information that one can come to a reasonable conclusion about their model or to find the areas where they need to dig a little deeper. 

## ML Training Evaluation

### Evaluation Metrics
This section contains statistics and variable importance measures to help the user understand model performance at a high level. Train Data results are included and can be used to compare against the Test Data results to identify over / under fitting of models.

### Evaluation Plots 
This section contains visualizations that span the range of predicted values and the associated accuracies across that range. The predicted values range is broken up into every 5th percentile to provide a wide range for evaluation.

### Model Interpretation sections 
This section contains visualizations intended to open up the black box of your algorithm. When one inspects coefficients from a regression model, the insights they gain are two-fold: 
- get an understanding about statistics significance
- gain an understanding of the variable's effect on the target variable
However, not all relationships are linear and sometimes the user doesn't specifiy an appropriate model structure to fully capture the nature of the relationship, which can lead to incorrect conclusions about both statistical signifance and the nature of the relationship. These visualizations provide a way to understand what the exact nature of those relationships are (in a visual manner) and if the user chooses, they can attempt to fit the relationship more precisely with an appropriate statistical model in order to gain a better understanding of statistical significance.

## Backtesting Evaluation
The backtesting evaluation consists of several outputs:
- Table of Metrics
- Line Plot of Target Variable and Predictions
- Line Plot of Average Error
- Line Plot of Absolute Error
- Line Plot of Squared Error
- Line Plot of SMAPE

## Feature Tuning Evaluation
This procedure produces a table of metrics that compare the performance of including / excluding various features from the forecasting model. If a feature is successful then it remains in the model moving forward while testing additional features. If not, it is excluded when testing new features. 

## Cross Validation Evaluation
This procedure produces a table of metrics for evaluating your updating strategy over time. For example, if you generate predictions on a weekly basis you can supply updated data, retrain your model, or both. You can specify the frequency at which both are updated. The table produces the metrics for you to understand the effectiveness of the updating strategy. Consider if you update both the values and model on a weekly basis but you don't see any gains over updating them monthly. From a cost perspective, you might as well update them monthly.

## Forecasting Evaluation
The forecasting procedure is for production purposes. Data output is supplied and a line plot of target and predicted is also supplied.


# <font size="6">ML Training Evaluation</font>

<details><summary>Expand</summary>


## <font size="6">Evaluation Metrics</font>
<p>

<details><summary>Expand</summary>
<p>



###  <font size="5">Evaluation Metrics</font>
<p>

<details><summary>Evaluation Metrics</summary>
<p>

```{r ML_Evaluation_Metrics, echo=FALSE}
if(!is.null(ML_Evaluation_Metrics)) {
  eval(ML_Evaluation_Metrics)
}
```

</details>
</p>




###  <font size="5">Variable Importance Tables</font>
<p>

<details><summary>Variable Importance Table</summary>
<p>

```{r ML_Test_Importance, echo=FALSE}
if(!is.null(ML_Test_Importance)) {
  ML_Test_Importance
}
```

</details>
</p>




###  <font size="5">Interaction Importance Tables</font>

<details><summary>Interaction Importance Tables</summary>
<p>

```{r ML_Interaction_Importance, echo=FALSE}
if(exists("All_Interaction") && !is.null(All_Interaction)) {
  ML_Interaction_Importance
} else {
  print('Interaction importance is only available with CatBoost')
}
```

</details>
</p>





## <font size="6">Evaluation Plots</font>
<p>

<details><summary>Expand</summary>
<p>


## <font size="5">Residual Histograms</font>
<p>

<details><summary>Expand</summary>
<p>

```{r ScoringData_Residual_Histogram, echo=FALSE}
if(!is.null(ScoringData_Residual_Histogram)) {
  eval(ScoringData_Residual_Histogram)
}
```

</details>
</p>




## <font size="5">Calibration Plots</font>
<p>

<details><summary>Expand</summary>
<p>

```{r ScoringData_Calibration_Plot, echo=FALSE}
if(!is.null(ScoringData_Calibration_Plot)) {
  eval(ScoringData_Calibration_Plot)
}
```

</details>
</p>



## <font size="5">Calibration BoxPlots</font>
<p>

<details><summary>Expand</summary>
<p>

```{r ScoringData_Calibration_Box_Plot, echo=FALSE}
if(!is.null(ScoringData_Calibration_Box_Plot)) {
  eval(ScoringData_Calibration_Box_Plot)
}
```

</details>
</p>





## <font size="6">Model Interpretation</font>
<p>

<details><summary>Expand</summary>
<p>



### <font size="5">Partial Dependence Plots: Numeric-Features</font>
<p>

<details><summary>Expand</summary>
<p>


### Partial Dependence Line Plots
<p>

<details><summary>Partital Dependence Line Plots</summary>
<p>

```{r ScoringData_Partial_Dependence_Line_Plot, echo=FALSE}
options(warn = -1)
if(!is.null(ScoringData_Partial_Dependence_Line_Plot) && length(ScoringData_Partial_Dependence_Line_Plot) > 0) {
  echarts4r::e_arrange(ScoringData_Partial_Dependence_Line_Plot)
}
options(warn = 1)
```

</details>
</p>


### Partial Dependence Box Plots
<p>

<details><summary>Expand</summary>
<p>

```{r ScoringData_Partial_Dependence_Box_Plot, echo=FALSE}
options(warn = -1)
if(!is.null(ScoringData_Partial_Dependence_Box_Plot) && length(ScoringData_Partial_Dependence_Box_Plot) > 0) {
  echarts4r::e_arrange(ScoringData_Partial_Dependence_Box_Plot)
}
options(warn = 1)
```

</details>
</p>


### <font size="5">Partial Partial Dependence Plots: Categorical-Features</font> 
<p>


<details><summary>Partital Dependence Bar Plots</summary>
<p>

```{r ScoringData_Partial_Dependence_Bar_Plot, echo=FALSE}
options(warn = -1)
if(!is.null(ScoringData_Partial_Dependence_Bar_Plot) && length(ScoringData_Partial_Dependence_Bar_Plot) > 0) {
  echarts4r::e_arrange(ScoringData_Partial_Dependence_Bar_Plot)
}
options(warn = 1)
```

</details>
</p>

</details>
</p>


# <font size="6">Backtest Evaluation</font>
<p>

<details><summary>Expand</summary>
<p>

```{r Back_Test_Metrics, echo = FALSE}
if(length(Back_Test_Metrics) > 0) {
  eval(Back_Test_Metrics)
}
```


```{r p1, echo = FALSE}
if(length(p1) > 0) {
  eval(p1)
}
```

```{r p2, echo = FALSE}
if(length(p2) > 0) {
  eval(p2)
}
```

```{r p3, echo = FALSE}
if(length(p3) > 0) {
  eval(p3)
}
```

```{r p4, echo = FALSE}
if(length(p4) > 0) {
  eval(p4)
}
```

```{r p6, echo = FALSE}
if(length(p6) > 0) {
  eval(p6)
}
```


# <font size="6">Feature Tuning Evaluation</font>
<p>

<details><summary>Expand</summary>
<p>


```{r Feature_Tuning_Metrics, echo = FALSE}
if(length(Feature_Tuning_Metrics) > 0) {
  eval(Feature_Tuning_Metrics)
}
```

# <font size="6">Cross Evaluation</font>
<p>

<details><summary>Expand</summary>
<p>


```{r Cross_Eval_Test_Metrics, echo = FALSE}
if(length(Cross_Eval_Test_Metrics) > 0) {
  eval(Cross_Eval_Test_Metrics)
}
```



# <font size="6">Forecast Evaluation</font>
<p>

<details><summary>Expand</summary>
<p>


```{r Panel_Forecast_Data, echo = FALSE}
if(length(Panel_Forecast_Data) > 0) {
  eval(Panel_Forecast_Data)
}
```

```{r p7, echo = FALSE}
if(length(p7) > 0) {
  eval(p7)
}
```

</details>
